# 设计模式 

## 七大原则 : 

- 单一职责

- 接口隔离

- 依赖倒置

- 里氏替换

- 开闭原则

- 迪米特法则

- 合成复用

  

### 单一职责

  单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。

  - 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
  - 提高类的可读性。复杂性降低，自然其可读性会提高。
  - 提高系统的可维护性。可读性提高，那自然更容易维护了。
  - 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

  

  ### 接口隔离
  接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

  1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
  2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
  3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
  4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
  5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

  

  ### 依赖倒置

   依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。

  

  ### 里氏替换

   里氏替换原则通俗来讲就是:子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

  ### 开闭原则

  对扩展开发 对修改关闭

​	开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

#### 1. 对软件测试的影响

软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

#### 2. 可以提高代码的可复用性

粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

#### 3. 可以提高软件的可维护性

遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

  

  ### 迪米特

  其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。


但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

  ### 合成复用

它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

 

## 设计模式

  ### 创建型 

创建型模式分为以下几种。

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象

#### 单例

```java
public class Singleinstance {
    public volatile Singleinstance singleinstance;
    public Singleinstance getSingleinstance(){
        if(singleinstance!=null){
            synchronized (Object.class){
                if (singleinstance!=null){
                    Singleinstance singleinstance=new Singleinstance();
                }
            }
        }
        return singleinstance;
    }
}
 class Singleton {
    private Singleton() {  //私有构造方法，防止被实例化
    }
    /*使用一个内部类来维护单例 */
    private static class SingletonFactory {
        private static Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {  //获取实例
        return SingletonFactory.instance;
    }
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */
    public Object readResolve() {
        return getInstance();
    }
}
//枚举类
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  

```

#### 原型

```java
//具体原型类 浅clone 
class Realizetype implements Cloneable {
    Realizetype() {
        System.out.println("具体原型创建成功！");
    }
    public Object clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功！");
        return (Realizetype) super.clone();
    }
}

//原型模式的测试类
public class PrototypeTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        Realizetype obj1 = new Realizetype();
        Realizetype obj2 = (Realizetype) obj1.clone();
        System.out.println("obj1==obj2?" + (obj1 == obj2));
        
        //jackson实现深拷贝
         Student s=new Student();
        ObjectMapper objectMapper = new ObjectMapper();
       Student ss=objectMapper.readValue(objectMapper.writeValueAsString(s),Student.class);
    
    }
}
//深克隆




```

#### 工厂

工厂方法模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402163428.png" alt="image-20210402163428549" style="zoom: 67%;" />

```java
public class Factory {
//抽象产品 汽车
interface Product{
     void car();
     void color();
}
//具体实例 红色奔驰
class ConcreteProduct_benci implements Product{
    @Override
    public void car() {
        System.out.println("大本");
    }
    @Override
   public void color() {
        System.out.println("红色");
    }
}
//具体实例 黑色宝马
class ConcreteProduct_bmw implements Product{
    @Override
    public void car() {
        System.out.println("BMW");
    }
    @Override
    public void color() {
        System.out.println("黑色");
    }
}
//抽象 汽车工厂
interface AbstractFactory{
    Product factoryproce();
}
//奔驰厂
class BenciFactory implements AbstractFactory{
    @Override
    public Product factoryproce() {
       return new ConcreteProduct_benci();
    }
}
//宝马厂
class BmwFactory implements AbstractFactory{
    @Override
    public Product factoryproce() {
        return new ConcreteProduct_bmw();
    }
    @Override
    public weapon weaponproce() {
        return new Handweapon();
    }
}
//测试 
    public static void main(String[] args) {
        //奔驰厂生产奔驰
       new BenciFactory().factoryproce();
        //宝马厂生产宝马
       new BmwFactory().factoryproce();
    }
}
```

#### 抽象工厂

一个工厂生产多种产品 组成一个产品族

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402163630.png" alt="image-20210402163630097" style="zoom: 80%;" />



```java
public class Factory {
//抽象产品 汽车
interface Product{
     void car();
     void color();
}
//具体实例 红色奔驰
class ConcreteProduct_benci implements Product{
    @Override
    public void car() {
        System.out.println("大本");
    }
    @Override
   public void color() {
        System.out.println("红色");
    }
}
//具体实例 黑色宝马
class ConcreteProduct_bmw implements Product{
    @Override
    public void car() {
        System.out.println("BMW");
    }
    @Override
    public void color() {
        System.out.println("黑色");
    }
}
        /**  抽象武器类**/
interface weapon{
    void gan();
}
    /** 手枪 **/
class Handweapon implements weapon{
    @Override
    public void gan() {
        System.out.println("手枪");
    }
}
/**  狙击枪**/
class Longweapon implements weapon{
    @Override
    public void gan() {
        System.out.println("狙击枪");
    }
}
//抽象 汽车工厂
interface AbstractFactory{
    Product factoryproce();
     weapon weaponproce();
}
//奔驰厂
class BenciFactory implements AbstractFactory{
    @Override
    public Product factoryproce() {
       return new ConcreteProduct_benci();
    }
   @Override
    public weapon weaponproce() {
        return  new Longweapon();
    }}
//宝马厂
class BmwFactory implements AbstractFactory{
    @Override
    public Product factoryproce() {
        return new ConcreteProduct_bmw();
    }
    @Override
    public weapon weaponproce() {
        return new Handweapon();
    }
   
}
//测试 
    public static void main(String[] args) {
        //奔驰厂生产奔驰
       new BenciFactory().factoryproce();
        //宝马厂生产宝马
       new BmwFactory().factoryproce();
    }
}
```



#### 建造者

​	建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的[设计模式](http://c.biancheng.net/design_pattern/)被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

建造者（Builder）模式的主要角色如下。

1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
2. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
3. 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
4. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402163812.png" alt="image-20210402163812160" style="zoom:67%;" />

```java
/**复杂对象
**/
class Home{
    private String shafa;
    private String dianshi;
    private String chuang;
    public String getShafa() {
        return shafa;
    }

    public void setShafa(String shafa) {
        this.shafa = shafa;
    }

    public String getDianshi() {
        return dianshi;
    }

    public void setDianshi(String dianshi) {
        this.dianshi = dianshi;
    }

    public String getChuang() {
        return chuang;
    }

    public void setChuang(String chuang) {
        this.chuang = chuang;
    }

}
/**抽象建造者
**/
abstract class Builder {
    Home home=new Home();
   abstract public  void  shafa();
    abstract public  void  dianshi();
    abstract public  void  chuang();
    public Home getResult() {
        return home;
    }
}

/**具体建造者
**/
class MyBulider extends Builder{

    @Override
    public void shafa() {
        home.setShafa("好沙发");
    }

    @Override
    public void dianshi() {
        home.setDianshi("好电视");
    }

    @Override
    public void chuang() {
        home.setChuang("席梦思");
    }
}
/**指挥
**/
 class Directors {
    private Builder builder;
    public Directors(Builder builder) {
        this.builder = builder;
    }
    //产品构建与组装方法
    public Home construct() {
        builder.shafa();
        builder.dianshi();
        builder.chuang();
        return builder.getResult();
    }
}
public class Build {
    public static void main(String[] args) {
        Builder builder=new  MyBulider();
        Directors directors=new Directors(builder);
        Home home=directors.construct();
    }
}
```

### 结构型

1. **代理（Proxy）**模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. **适配器（Adapter）**模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. **装饰（Decorator）**模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：门面 运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

#### 代理模式

代理模式的主要角色如下。

1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture@master/img/image-20210402153643461.png" alt="image-20210402153643461" style="zoom:67%;" />

```java
/**
 * @Description 接口类
 * @author Ni Shengwu
 *
 */
 interface Star {

    public void confer(); //面谈
    public void sing(); //唱歌
    public void collectMoney(); //收钱
}

/**
 * @Description 真实对象
 * @author Ni Shengwu
 *
 */
 class RealStar implements Star {
    @Override
    public void confer() {
        System.out.println("设计模式.RealStar.confer()");
    }
    @Override
    public void sing() {
        System.out.println("设计模式.RealStar(周杰伦).sing()");
    }
    @Override
    public void collectMoney() {
        System.out.println("设计模式.RealStar.collectMoney()");
    }
}
public class StarHandler implements InvocationHandler {
    Star realStar;
    public StarHandler(Star realStar) {
        super();
        this.realStar = realStar;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        Object object = null;
        // 在代理真实对象前，我们可以做些自己的操作
        System.out.println("面谈");

        if(method.getName().equals("sing")) {
            object = method.invoke(realStar, args);
        }
        // 在代理真是对象后，我们可以做些自己的操作
        System.out.println("收钱");
        return object;
    }

}
//动态代理接口  jdk代理
 class Clients {
     public static void main(String[] args) {
        Star realStar = new RealStar();
        StarHandler handler = new StarHandler(realStar);
        //创建代理类
        Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Star.class}, handler);
        proxy.sing();
    }
}

  //lamdba 实现动态代理  jdk代理
        Star proxys = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Star.class}, (proxy, method, argss)->{
            Object object = null;
            // 在代理真实对象前，我们可以做些自己的操作
            System.out.println("面谈");
            if(method.getName().equals("sing")) {
                object = method.invoke(realStar, args);
            }
            // 在代理真是对象后，我们可以做些自己的操作
            System.out.println("收钱");
            return object;
        });

//cglib方式
class Cglib implements MethodInterceptor{
     private Star star;
    public Cglib(Star star) {
        this.star = star;
    }
    public Object getproxyInstance( ){
         /**第一行代码: Enhancer enhancer = new Enhancer();中的Enhancer是一个非常重要的类，它允许为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法，和JDK动态代理不一样的是不管是接口还是类它都能正常工作。
         
         第二行代码：enhancer.setSuperclass(target.getClass());这行代码的意思是设置被代理类字节码，为什么要设置被代理类的字节码呢？CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。所以需要获取字节码，巧妇难为无米之炊哈。
         
         第三行代码：enhancer.setCallback(this);设置回调函数,这里有一个参数this表示当前对象也就是cglibUser对象，因为cglibUser类实现了接口MethodInterceptor,也实现了接口的方法：intercept，这个方法就是回调方法。当我们去调用代理类对象的方法时就会转变为去执行这个方法。
         
         第四行代码：return (UserDao) enhancer.create();这行代码就是去创建目标对象的代理对象，他是通过创建目标对象的子类对象来实现的。
        **/
        Enhancer enhancer=new Enhancer();
        enhancer.setSuperclass(star.getClass());
        enhancer.setCallback(this);
        //需要注意的是，无参的create()方法默认调用被代理类Student的无参构造函数来初始化，如果希望通过有参的构造函数初始化				Student，也可以调用create()的一个重载版本
        //需要传入两个参数，第一个是Student构造函数的参数列表的Class数组，第二个是对应的值。
       // return enhancer.create(new Class<?>[]{String.class}, new Object[]{""});
        return enhancer.create();
    }
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib");
        method.invoke(star,objects);
        return null;
    }
}

```

#### 适配器

​	适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

- Target：目标抽象类

- Adapter：适配器类

- Adaptee：适配者类

- Client：客户类

  <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/img/image-20210402154905229.png" alt="image-20210402154905229" style="zoom:67%;" />

  <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402173837.png" alt="image-20210402173837774" style="zoom:67%;" />
  
  
  
  **代码应用:spring mvc dispatcher**

```java
// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class Adaptee {
    public void specificRequest() {
        System.out.println("被适配类具有 特殊功能...");
    }
}
// 目标接口，或称为标准接口
interface Target {
    public void request();
}

// 具体目标类，只提供普通功能
class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println("普通类 具有 普通功能...");
    }
}
// 1适配器类  继承方式
public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        //调用父类的特殊功能
        super.specificRequest();
    }
    // 测试类public class 设计模式.Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();
        concreteTarget.request();

        // 使用特殊功能类，即适配类
        Target adapter = new Adapter();
        adapter.request();
        Target adapter_two=new Adapter_two(new Adaptee());
        adapter_two.request();

    }
}

// 2通过组合方式(构造器方式) 减少类的管理 
class Adapter_ implements Target{
    private Adaptee adaptee;
    public Adapter_(Adaptee adaptee){
        this.adaptee=adaptee;
    }
    @Override
    public void request() {
        adaptee.request();
    }
}
```



#### 桥接

​	桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

- Abstraction：抽象类

- RefinedAbstraction：扩充抽象类 s

- Implementor：实现类接口

- ConcreteImplementor：具体实现类

  <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402173917.png" alt="image-20210402173917245" style="zoom: 67%;" />

```java
//实现类接口
interface Color{
    String coler_print();
}
//具体实现类 红色
class red_color implements Color{
    @Override
    public String coler_print() {
        return new String("red");
    }
}
//具体实现类 黄色
class yellow_color implements Color{
    @Override
    public String coler_print() {
        return new String("yellow");
    }
}
//抽象扩充类
abstract class phone{
    protected   Color color;
    phone(Color color){
        this.color=color;
    }
    abstract void phone();

}
//小米手机
class miphone extends phone{
    miphone(Color color) {
        super(color);
    }
    @Override
    void phone() {
        System.out.println("小米手机"+color.coler_print());
    }
}
//华为
class huweiphone extends phone{
    huweiphone(Color color) {
        super(color);
    }
    @Override
    void phone() {
        System.out.println("华为手机"+color.coler_print());
    }
}
```

#### 装饰器

​	装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

装饰器模式主要包含以下角色。

1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402175520.png" alt="image-20210402175520842" style="zoom:67%;" />

应用:FileinputStream

```java
//测试
public class decorator {
    public static void main(String[] args) {
       Programer programer= new java_programer();
        decorater decorater= new decorater_python(programer);
        decorater.language();
    }
}
//  程序员 抽象构建
interface  Programer{
    void language();
}
//一个java程序员 具体构件
class java_programer implements Programer{
    @Override
    public void language() {
        System.out.println("我会java");
    }
}

//抽象修饰 
class decorater implements Programer{
    private Programer programer;
    decorater(Programer programer){
        this.programer=programer;
    }
    @Override
    public void language() {
        programer.language();
    }
}
//具体修饰 会python了
class decorater_python {
    decorater_python(Programer programer) {
        super(programer);
    }
    public void language() {
        super.language();
        addedFunction();
    }
    //新的语言
    public void addedFunction() {
        System.out.println("我还会python");
    }
}
```

 

#### 组合模式

​	组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185721.png" alt="image-20210402185721895" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185748.png" alt="image-20210330151408739" style="zoom:80%;" />

 应用:HashMap

```java
// 安全模式
public interface Component {
    void  operation();
}
//叶子无 add remove方法
class  left implements Component{
    public left(String name) {
        this.name = name;
    }
    private String name;
    @Override
    public void operation() {
        System.out.println(name);
    }
}
//管理叶子的节点 
class  Composite implements Component{
    private String name;

    public Composite(String name) {
        this.name = name;
    }
    ArrayList<Component> arrayList=new ArrayList<Component>();
    //添加子节点
    public void add(Component component){
        arrayList.add(component);
    }
    //删除子节点
    public void remove(Component component){
        arrayList.remove(component);
    }
    //获取子子节点
    public Component getChild(int i) {
        return arrayList.get(i);
    }
    @Override
    public void operation() {
        for (Object obj : arrayList) {
            ((Component) obj).operation();
        }
    }
}
class Components{
    public static void main(String[] args) {
       Component left_1=new left("left1");
        Component left_2=new left("left2");
        Component left_3=new left("left3");
        Composite compsite_1=new Composite("管理_1");
        Composite compsite_2=new Composite("管理_2");
        compsite_1.add(left_1);
        compsite_1.add(left_2);
        compsite_2.add(left_3);
        compsite_2.add(compsite_1);
        compsite_2.operation();
    }
}
```



#### 外观模式

​	外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。



<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185802.png" alt="image-20210330154436074" style="zoom:80%;" />

 应用:mybatis 

```java
class FacadePattern {
    public static void main(String[] args) {
        Facade f = new Facade();
        f.method();
    }
}
//外观角色
class Facade {
    private SubSystem01 obj1 = new SubSystem01();
    private SubSystem02 obj2 = new SubSystem02();
    private SubSystem03 obj3 = new SubSystem03();
    public void method() {
        obj1.method1();
        obj2.method2();
        obj3.method3();
    }
} 
//子系统角色
class SubSystem01 {
    public void method1() {
        System.out.println("子系统01的method1()被调用！");
    }
}
//子系统角色
class SubSystem02 {
    public void method2() {
        System.out.println("子系统02的method2()被调用！");
    }
}
//子系统角色
class SubSystem03 {
    public void method3() {
        System.out.println("子系统03的method3()被调用！");
    }
}
```



#### 享元模式

1. 抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
2. 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
3. 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
4. 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象

<img src=" https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185839.png" alt="image-20210330160008782" style="zoom:67%;" />

```java
class FlyweightPattern {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight f01 = factory.getFlyweight("a");
        Flyweight f02 = factory.getFlyweight("a");
        Flyweight f03 = factory.getFlyweight("a");
        Flyweight f11 = factory.getFlyweight("b");
        Flyweight f12 = factory.getFlyweight("b");
        f01.operation(new UnsharedConcreteFlyweight("第1次调用a。"));
        f02.operation(new UnsharedConcreteFlyweight("第2次调用a。"));
        f03.operation(new UnsharedConcreteFlyweight("第3次调用a。"));
        f11.operation(new UnsharedConcreteFlyweight("第1次调用b。"));
        f12.operation(new UnsharedConcreteFlyweight("第2次调用b。"));
    }
}
//非享元角色
class UnsharedConcreteFlyweight {
    private String info;
    UnsharedConcreteFlyweight(String info) {
        this.info = info;
    }
    public String getInfo() {
        return info;
    }
    public void setInfo(String info) {
        this.info = info;
    }
}
//抽象享元角色
interface Flyweight {
    public void operation(UnsharedConcreteFlyweight state);
}
//具体享元角色
class ConcreteFlyweight implements Flyweight {
    private String key;
    ConcreteFlyweight(String key) {
        this.key = key;
        System.out.println("具体享元" + key + "被创建！");
    }
    public void operation(UnsharedConcreteFlyweight outState) {
        System.out.print("具体享元" + key + "被调用，");
        System.out.println("非享元信息是:" + outState.getInfo());
    }
}
//享元工厂角色
class FlyweightFactory {
    private HashMap<String, Flyweight> flyweights = new HashMap<String, Flyweight>();
    public Flyweight getFlyweight(String key) {
        Flyweight flyweight = (Flyweight) flyweights.get(key);
        if (flyweight != null) {
            System.out.println("具体享元" + key + "已经存在，被成功获取！");
        } else {
            flyweight = new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        }
        return flyweight;
    }
}
```

### 行为型

行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。

1. **模板方法**（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. **策略**（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. **中介者（Mediator）模式**：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器. 



#### 模板方法

​	① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。

​	② 基本方法：是整个算法中的一个步骤，包含以下几种类型。

- 抽象方法：在抽象类中声明，由具体子类实现。
- 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
- 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。

<img src=" https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185844.png" alt="image-20210401120448467" style="zoom:80%;" />

应用: AQS

```java
public class TemplateMethodPattern {
    public static void main(String[] args) {
        AbstractClass tm = new ConcreteClass();
        tm.TemplateMethod();
    }
}
//抽象类
abstract class AbstractClass {
    //模板方法
    public void TemplateMethod() {
        SpecificMethod();
        abstractMethod1();
        abstractMethod2();
    }
    //具体方法
    public void SpecificMethod() {
        System.out.println("抽象类中的具体方法被调用...");
    }
    //抽象方法1
    public abstract void abstractMethod1();
    //抽象方法2
    public abstract void abstractMethod2();
}
//具体子类 重写抽象的方法
class ConcreteClass extends AbstractClass {
    public void abstractMethod1() {
        System.out.println("抽象方法1的实现被调用...");
    }
    public void abstractMethod2() {
        System.out.println("抽象方法2的实现被调用...");
    }
}
```



#### 命令模式

命令模式包含以下主要角色。

1. 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。

2. 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。

3. 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。

4. 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

   *解耦调用者与实现者*

<img src=" https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185847.png" alt="image-20210401130018061" style="zoom: 80%;" />

```java
class CommandPattern {
    public static void main(String[] args) {
        Command cmd = new ConcreteCommand_1();
        Command cmd2 = new ConcreteCommand_2();
        Invoker ir = new Invoker(cmd);
        System.out.println("开电灯");
        ir.call();
        ir.setCommand(cmd2);
        System.out.println("开电视");
        ir.call();
    }
}

//调用者
class Invoker {
    private Command command;
    public Invoker(Command command) {
        this.command = command;
    }

    public void setCommand(Command command) {
        this.command = command;
    }

    public void call() {
        command.execute();
    }
}

//抽象命令
interface Command {
    public abstract void execute();
}

//电灯具体命令
class ConcreteCommand_1 implements Command {
    private Receiver_2 receiver_2;
     ConcreteCommand_1() {
        receiver_2 = new Receiver_2();
    }
    public void execute() {
        receiver_2.action();
    }
}
//电视具体命令
class ConcreteCommand_2 implements Command {
    private Receiver_1 receiver_1;

    ConcreteCommand_2() {
        receiver_1 = new Receiver_1();
    }

    public void execute() {
        receiver_1.action();
    }
}

//电灯命令接收者
class Receiver_2 {
    public void action() {
        System.out.println("电灯开了");
    }
}
//电视命令接收者
class Receiver_1 {
    public void action() {
        System.out.println("电视开了");
    }
}

```

#### 访问模式

访问者模式包含以下主要角色。

1. 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
2. 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
3. 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
4. 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
5. 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。

<img src=" https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185851.png" alt="image-20210401223233398" style="zoom:67%;" />

```java
public class Vister {
    public static void main(String[] args) {
        Vister_list vister=new Vister_list();
        Pencail pencail= new Pencail();
        Book book=new Book();
        //添加元素
        vister.add(book);
        vister.add(pencail);
		//添加访问者
        Teacher teacher=new Teacher();
        Student student=new Student();
        vister.accept(teacher);
        vister.accept(student);
    }

}
// 不同人 拿到纸和笔的行为不一样
interface  Person{
    String create(Pencail pencail);
    String create(Book book);
}

//文具类 接受访问对象 person
interface material{
    String accept(Person pserson);
}
//笔
class Pencail implements  material{
    @Override
    public String accept(Person pserson) {
        return pserson.create(this);
    }
}
//笔记本
class Book implements  material{
    @Override
    public String accept(Person pserson) {
        return pserson.create(this);
    }
}
class  Teacher implements Person{
    @Override
    public String create(Pencail pencail) {
        System.out.println("批改作业");
        return "批改作业";
    }
    @Override
    public String create(Book book) {
        System.out.println("备课");
        return "备课";
    }
}
class  Student implements Person{
    @Override
    public String create(Pencail pencail) {
        System.out.println("写作业");
        return " 写作业";
    }
    @Override
    public String create(Book book) {
        System.out.println("记笔记");
        return "记笔记";
    }
}

class Vister_list{
    ArrayList<material> arrayList=new ArrayList<>();
    public void  add(material meatial){
        arrayList.add(meatial);
    }

    public void remove(material meatial){
        arrayList.remove(meatial);
    }

    public void accept(Person person){
        arrayList.stream().forEach(meatials -> meatials.accept(person));
    }
        }
```



#### 迭代器模式

迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。

1. 访问一个聚合对象的内容而无须暴露它的内部表示。
2. 遍历任务交由迭代器完成，这简化了聚合类。
3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。
5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185855.png" alt="image-20210401223157698" style="zoom:67%;" />

应用: java集合类

```java
interface Aggregate {
    void add(Object obj);

    void remove(Object obj);

    Iterator getIterator();
}

//抽象迭代器
interface Iterator {
    Object first();

    Object next();

    boolean hasNext();
}

public class IteratorPattern {
    public static void main(String[] args) {
        Aggregate ag = new ConcreteAggregate();
        ag.add("中山大学");
        ag.add("华南理工");
        ag.add("韶关学院");
        System.out.print("聚合的内容有：");
        Iterator it = ag.getIterator();
        while (it.hasNext()) {
            Object ob = it.next();
            System.out.print(ob.toString() + "\t");
        }
        Object ob = it.first();
        System.out.println("\nFirst：" + ob.toString());
    }
}

//具体聚合
class ConcreteAggregate implements Aggregate {
    private final List<Object> list = new ArrayList<Object>();

    public void add(Object obj) {
        list.add(obj);
    }

    public void remove(Object obj) {
        list.remove(obj);
    }

    public Iterator getIterator() {
        return (new ConcreteIterator(list));
    }
}

//具体迭代器
class ConcreteIterator implements Iterator {
    private List<Object> list = null;
    private int index = -1;

    public ConcreteIterator(List<Object> list) {
        this.list = list;
    }

    public boolean hasNext() {
        return index < list.size() - 1;
    }

    public Object first() {
        index = 0;
        Object obj = list.get(index);
        return obj;
    }

    public Object next() {
        Object obj = null;
        if (this.hasNext()) {
            obj = list.get(++index);
        }
        return obj;
    }}
```

#### 观察者模式

观察者模式的主要角色如下。

1. 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
2. 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
3. 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
4. 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402185929.png" alt="image-20210401223704284" style="zoom:67%;" />



```java
/**观察者模式
**/
public class Observer{
    public static void main(String[] args) {
        //气象站
        AnHuiWeatherData weatherData=new AnHuiWeatherData();
        //订阅者 芜湖与合肥
        Observers observersHeFei=new ObserverHeiFeiTv();
        Observers observersWuHu=new ObserverWuHuTv();
        //添加订阅
        weatherData.add(observersHeFei);
        weatherData.add(observersWuHu);
        /**温度改变时通知订阅者
        **/
        weatherData.setData(1,2,3);
    }
        }
//抽象主题 观察者观察的目标
interface WeatherData{
    void add(Observers observers);
    void remove(Observers observers);
    void notifyObservers();
}

//抽象观察者
interface Observers{
    void response(int shidu,int wendu,int fengli);
}

/**天气站 被观察者/被订阅者
**/
class AnHuiWeatherData implements WeatherData{
    /**定义 湿度 温度 风力
    **/
    private  int shidu;
    private  int wendu;
    private  int fengli;
//温度变化
    public void setData(int shidu,int wendu,int fengli){
        this.shidu=shidu;
        this.fengli=fengli;
        this.wendu=wendu;
        notifyObservers();
    }
//订阅者集合
    LinkedList<Observers> observerList=new LinkedList<>();
    /**注册订阅
    **/
    @Override
    public void add(Observers observers) {
        observerList.add(observers);
    }
/**删除订阅
**/
    @Override
    public void remove(Observers observers) {
        observerList.remove(observers);
    }
/**通知订阅变动
**/
    @Override
    public void notifyObservers() {
            observerList.stream().forEach(observers -> observers.response(shidu,wendu,fengli));
    }
}
//观察者 合肥
class ObserverHeiFeiTv implements Observers{
    @Override
    public void response(int shidu, int wendu, int fengli) {
        System.out.println("合肥"+"湿度="+shidu+"||"+"稳定="+wendu+"||"+"风力="+fengli);
    }
}
//观察者 芜湖
class ObserverWuHuTv implements Observers{
    @Override
    public void response(int shidu, int wendu, int fengli) {
        System.out.println("芜湖"+"湿度="+shidu+"||"+"稳定="+wendu+"||"+"风力="+fengli);
    }
}
```

#### 策略模式

策略模式的主要角色如下。

1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
2. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
3. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

<img src=" https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190006.png" alt="image-20210402190006232" style="zoom:67%;" />

应用:集合的comparator

```java
/**
 * 抽象烧饭策略
 **/
interface Strategys {
    void Cooking();
}

/**
 * 策略模式
 **/
public class Strategy {

    public static void main(String[] args) {
        /**厨房
         **/
        ChuFang chuFang = new ChuFang();
        /**两种策略
         **/
        Strategys chuangCai = new ChuangCai();
        Strategys xianCair = new XianCair();
        /**传入不同属性 不同的结果
         **/
        chuFang.setStrategys(chuangCai);
        chuFang.strategyMeathod();
        chuFang.setStrategys(xianCair);
        chuFang.strategyMeathod();
    }
}
/**湘菜策略
**/
class XianCair implements Strategys {

    @Override
    public void Cooking() {
        System.out.println("烧湘菜");
    }
}
/**川菜策略
**/
class ChuangCai implements Strategys {

    @Override
    public void Cooking() {
        System.out.println("烧川菜");
    }
}
/**策略接收者 厨房
**/
class ChuFang {
    private Strategys strategys;

    public Strategys getStrategys() {
        return strategys;
    }
    /**组合 传入策略
    **/
    public void setStrategys(Strategys strategys) {
        this.strategys = strategys;
    }

    /**
     * 统一对外接口
     **/
    public void strategyMeathod() {
        strategys.Cooking();
    }


}
```

#### 中介者模式

中介者模式包含以下主要角色。

1. 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。

2. 具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。

3. 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。

4. 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

   中介者模式是一种对象行为型模式，其主要优点如下。

   1. 类之间各司其职，符合迪米特法则。
   2. 降低了对象之间的耦合性，使得对象易于独立地被复用。
   3. ==将对象间的一对多关联转变为一对一的关联==，提高系统的灵活性，使得系统易于维护和扩展。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190044.png" alt="image-20210402190044191" style="zoom:67%;" />

```java
public class MediatorPattern {
    public static void main(String[] args) {
        Mediator md = new ConcreteMediator();
        Colleague c1, c2,c3;
        c1 = new ConcreteColleague1();
        c2 = new ConcreteColleague2();
        c3 = new ConcreteColleague3();
        md.register(c1);
        md.register(c2);
        md.register(c3);
        c1.send();
        System.out.println("-------------");
        c2.send();

        /**具体同事类1发出请求。
         具体同事类2收到请求。
         具体同事类3收到请求。
         -------------
         具体同事类2发出请求。
         具体同事类1收到请求。
         具体同事类3收到请求。
         **/
    }
}

//抽象中介者
abstract class Mediator {
    /**注册同事
    **/
    public abstract void register(Colleague colleague);
    /**转发消息
    **/
    public abstract void relay(Colleague cl); //转发
}

//具体中介者
class ConcreteMediator extends Mediator {
    /**存储全部的同事
    **/
    private List<Colleague> colleagues = new ArrayList<Colleague>();

    /**插入 并让同事持有中介信息
    **/
    @Override
    public void register(Colleague colleague) {
        if (!colleagues.contains(colleague)) {
            colleagues.add(colleague);
            colleague.setMedium(this);
        }
    }

    /**接受同事发出的消息
    **/
    @Override
    public void relay(Colleague cl) {
        for (Colleague ob : colleagues) {
            if (!ob.equals(cl)) {
                ((Colleague) ob).receive();
            }
        }
    }
}

//抽象同事类
abstract class Colleague {
    /**中介
    **/
    protected Mediator mediator;
    /**持有中介
    **/
    public void setMedium(Mediator mediator) {
        this.mediator = mediator;
    }
    /**接受其他同事消息
    **/
    public abstract void receive();
    /**发送消息
    **/
    public abstract void send();
}

//具体同事类
class ConcreteColleague1 extends Colleague {
    @Override
    public void receive() {
        System.out.println("具体同事类1收到请求。");
    }

    @Override
    public void send() {
        System.out.println("具体同事类1发出请求。");
        mediator.relay(this); //请中介者转发
    }
}
//具体同事类
class ConcreteColleague3 extends Colleague {
    @Override
    public void receive() {
        System.out.println("具体同事类3收到请求。");
    }

    @Override
    public void send() {
        System.out.println("具体同事类3发出请求。");
        mediator.relay(this); //请中介者转发
    }
}

//具体同事类
class ConcreteColleague2 extends Colleague {
    @Override
    public void receive() {
        System.out.println("具体同事类2收到请求。");
    }
    @Override
    public void send() {
        System.out.println("具体同事类2发出请求。");
        mediator.relay(this); //请中介者转发
    }
}

```

#### 备忘录模式

备忘录模式的主要角色如下。

1. 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
2. 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
3. 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190114.png" alt="image-20210402190114235" style="zoom:67%;" />

```java
public class MementoPattern {
    public static void main(String[] args) {
        Originator or = new Originator();
        Caretaker cr = new Caretaker();
        or.setState("S0");
        System.out.println("初始状态:" + or.getState());
        cr.setMemento(or.createMemento()); //保存状态
        or.setState("S1");
        System.out.println("新的状态:" + or.getState());
        cr.setMemento(or.createMemento()); //保存状态
        or.setState("S3");
        System.out.println("新的状态:" + or.getState());
        cr.setMemento(or.createMemento()); //保存状态
        or.restoreMemento(cr.getMemento(0)); //恢复状态
        System.out.println("恢复状态:" + or.getState());
        /*初始状态:S0
		新的状态:S1
		新的状态:S3
		恢复状态:S0		
        */
    }
}
//备忘录
class Memento {
    private String state;
    public Memento(String state) {
        this.state = state;
    }
    public void setState(String state) {
        this.state = state;
    }
    public String getState() {
        return state;
    }
}
//发起人
class Originator {
    /**状态
    **/
    private String state;
    public void setState(String state) {
        this.state = state;
    }
    public String getState() {
        return state;
    }
    /**创建备忘录 写入状态
    **/
    public Memento createMemento() {
        return new Memento(state);
    }
    public void restoreMemento(Memento m) {
        this.setState(m.getState());
    }
}
//管理者
class Caretaker {
    private LinkedList<Memento> memento=new LinkedList<>();
    public void setMemento(Memento m) {
        memento.add(m);
    }
    public Memento getMemento(int index) {
        return memento.get(index);
    }
}
```

#### 解析器模式

解释器模式包含以下主要角色。

1. 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
2. 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
3. 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
4. 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
5. 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190144.png" alt="image-20210402190144409" style="zoom:67%;" />

```java
public class InterpreterPatternDemo {
    public static void main(String[] args) {
        Context bus = new Context();
        bus.freeRide("韶关的老人");
        bus.freeRide("韶关的年轻人");
        bus.freeRide("广州的妇女");
        bus.freeRide("广州的儿童");
        bus.freeRide("山东的儿童");
    }
}
//抽象表达式类
interface Expression {
    public boolean interpret(String info);
}
//终结符表达式类
class TerminalExpression implements Expression {
    private Set<String> set = new HashSet<String>();
    public TerminalExpression(String[] data) {
        for (int i = 0; i < data.length; i++) set.add(data[i]);
    }
    public boolean interpret(String info) {
        if (set.contains(info)) {
            return true;
        }
        return false;
    }
}
//非终结符表达式类
class AndExpression implements Expression {
    private Expression city = null;
    private Expression person = null;
    public AndExpression(Expression city, Expression person) {
        this.city = city;
        this.person = person;
    }
    public boolean interpret(String info) {
        String s[] = info.split("的");
        return city.interpret(s[0]) && person.interpret(s[1]);
    }
}
//环境类
class Context {
    private String[] citys = {"韶关", "广州"};
    private String[] persons = {"老人", "妇女", "儿童"};
    private Expression cityPerson;
    public Context() {
        Expression city = new TerminalExpression(citys);
        Expression person = new TerminalExpression(persons);
        cityPerson = new AndExpression(city, person);
    }
    public void freeRide(String info) {
        boolean ok = cityPerson.interpret(info);
        if (ok) {
            System.out.println("您是" + info + "，您本次乘车免费！");
        } else {
            System.out.println(info + "，您不是免费人员，本次乘车扣费2元！");
        }
    }
}
```

#### 状态模式

状态模式包含以下主要角色。

1. 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
2. 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
3. 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190225.png" alt="image-20210402190225010" style="zoom:67%;" />

```java
public class ScoreStateTest {
    public static void main(String[] args) {
        ScoreContext account = new ScoreContext();
        System.out.println("学生成绩状态测试：");
        account.add(30);
        account.add(40);
        account.add(25);
        account.add(-15);
        account.add(-25);
        
        /*学生成绩状态测试：
加上：30分，	当前分数：30分，	当前状态：不及格
加上：40分，	当前分数：70分，	当前状态：中等	
加上：25分，	当前分数：95分，	当前状态：优秀
加上：-15分，	当前分数：80分，	当前状态：中等
加上：-25分，	当前分数：55分，	当前状态：不及格z
        */
    }
}

//环境类
class ScoreContext {
    private AbstractState state;

    ScoreContext() {
        state = new LowState(this);
    }

    public void setState(AbstractState state) {
        this.state = state;
    }

    public AbstractState getState() {
        return state;
    }

    public void add(int score) {
        state.addScore(score);
    }
}

//抽象状态类
abstract class AbstractState {
    protected ScoreContext hj;  //环境
    protected String stateName; //状态名
    protected int score; //分数

    public abstract void checkState(); //检查当前状态

    public void addScore(int x) {
        score += x;
        System.out.print("加上：" + x + "分，\t当前分数：" + score);
        checkState();
        System.out.println("分，\t当前状态：" + hj.getState().stateName);
    }
}

//具体状态类：不及格
class LowState extends AbstractState {
    public LowState(ScoreContext h) {
        hj = h;
        stateName = "不及格";
        score = 0;
    }

    public LowState(AbstractState state) {
        hj = state.hj;
        stateName = "不及格";
        score = state.score;
    }

    @Override
    public void checkState() {
        if (score >= 90) {
            hj.setState(new HighState(this));
        } else if (score >= 60) {
            hj.setState(new MiddleState(this));
        }
    }
}

//具体状态类：中等
class MiddleState extends AbstractState {
    public MiddleState(AbstractState state) {
        hj = state.hj;
        stateName = "中等";
        score = state.score;
    }

    @Override
    public void checkState() {
        if (score < 60) {
            hj.setState(new LowState(this));
        } else if (score >= 90) {
            hj.setState(new HighState(this));
        }
    }
}

//具体状态类：优秀
class HighState extends AbstractState {
    public HighState(AbstractState state) {
        hj = state.hj;
        stateName = "优秀";
        score = state.score;
    }

    @Override
    public void checkState() {
        if (score < 60) {
            hj.setState(new LowState(this));
        } else if (score < 90) {
            hj.setState(new MiddleState(this));
        }
    }
}
```

#### 责任链模式

职责链模式主要包含以下角色。

1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210402190254.png" alt="image-20210402190254587" style="zoom:67%;" />

```java
 class LeaveRequest {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getLeaveDays() {
        return leaveDays;
    }

    public void setLeaveDays(int leaveDays) {
        this.leaveDays = leaveDays;
    }

    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }

    private int leaveDays;
    private String reason;

    public LeaveRequest(String name, int leaveDays, String reason) {
        super();
        this.name = name;
        this.leaveDays = leaveDays;
        this.reason = reason;
    }

}
/**
 * @Description 领导的抽象类
 * @author Ni Shengwu
 *
 */
 abstract class Leader {

    protected String name;
    protected Leader nextLeader; //责任链上的后继对象，即这个对象无法处理，就转移给下一个Leader

    public Leader(String name) {
        super();
        this.name = name;
    }
    // 设定责任链上的后继对象
    public void setNextLeader(Leader nextLeader) {
        this.nextLeader = nextLeader;
    }

    /**
     * 处理请求的核心的业务方法
     * 需要不同继承该类的领导自己实现
     */
    public abstract void handleRequest(LeaveRequest request);

}
/**
 * @Description 主任
 * @author Ni Shengwu
 *
 */
 class Director extends Leader {
    public Director(String name) {
        super(name);
    }
    @Override
    public void handleRequest(LeaveRequest request) {

        int days = request.getLeaveDays(); //获取请假天数
        String name = request.getName(); //获取请假人姓名
        String reason = request.getReason(); // 获取请假理由

        if(days <= 3) { //如果满足3天内的要求，主任直接审批
            System.out.println("员工" + name + "请假" + days + "天，理由：" + reason);
            System.out.println("主任" + this.name + "审批通过");
        } else {
            System.out.println("请假天数过多，主任" + this.name + "没法处理");
            if(this.nextLeader != null) { //否则，如果链上存在下一个Leader，就让他处理
                this.nextLeader.handleRequest(request);
            }
        }
    }

}
/**
 * @Description 经理
 * @author Ni Shengwu
 *
 */
 class Manager extends Leader {

    public Manager(String name) {
        super(name);
    }

    @Override
    public void handleRequest(LeaveRequest request) {

        int days = request.getLeaveDays(); //获取请假天数
        String name = request.getName(); //获取请假人姓名
        String reason = request.getReason(); // 获取请假理由

        if(days <= 10) { //如果满足10天内的要求，经理直接审批
            System.out.println("员工" + name + "请假" + days + "天，理由：" + reason);
            System.out.println("经理" + this.name + "审批通过");
        } else {
            System.out.println("请假天数过多，经理" + this.name + "没法处理");
            if(this.nextLeader != null) { //否则，如果链上存在下一个Leader，就让他处理
                this.nextLeader.handleRequest(request);
            }
        }
    }}
    /**
     * @Description 总经理
     * @author Ni Shengwu
     *
     */
     class GeneralManager extends Leader {

        public GeneralManager(String name) {
            super(name);
        }

        @Override
        public void handleRequest(LeaveRequest request) {

            int days = request.getLeaveDays(); //获取请假天数
            String name = request.getName(); //获取请假人姓名
            String reason = request.getReason(); // 获取请假理由

            if(days <= 30) { //如果满足30天内的要求，总经理直接审批
                System.out.println("员工" + name + "请假" + days + "天，理由：" + reason);
                System.out.println("总经理" + this.name + "审批通过");
            } else {
                System.out.println("请假天数过多，总经理" + this.name + "没法处理");
                if(this.nextLeader != null) { //否则，如果链上存在下一个Leader，就让他处理
                    this.nextLeader.handleRequest(request);
                } else {
                    System.out.println("请假不成功");
                }
            }
        }

    }

public class chain {

    public static void main(String[] args) {

        Leader director = new Director("张三");
        Leader manager = new Manager("李四");
        Leader gManager = new GeneralManager("王五");

        // 组织好责任链对象的关系
        director.setNextLeader(manager);
        manager.setNextLeader(gManager);

        // 开始请假操作
        LeaveRequest request = new LeaveRequest("倪升武", 15, "在家睡觉");
        director.handleRequest(request);
        
        /*请假天数过多，主任张三没法处理
		请假天数过多，经理李四没法处理
		员工倪升武请假15天，理由：在家睡觉
		总经理王五审批通过
		*/
    }

}
```