# 结构

- 顺序存储 空间连续
- 链式存储 空间不连续 

## 线性结构

​	数组 链表 队列 栈 

​	*数组链表区别*

​	数组顺序存储 空间固定   链表链式存储 空间不固定

|     复杂度     | 数组         | 链表         |
| :------------: | :----------- | ------------ |
|   按下标查询   | o(1)         | o(n)         |
|    按值查询    | o(n)         | o(n)         |
| 头部 插入 删除 | o(n)需要位移 | o(1)         |
|  尾部插入删除  | o(1)         | o(n)需要遍历 |
|  中间插入删除  | o(n)需要位移 | o(n)需要遍历 |



## 非线性结构

​	多维数组  树   图   广义表 

## 稀疏矩阵的转置 

![image-20210404230950354](https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210404230950.png)

三元组保存稀疏矩阵 

 	转置 公式

$cpot(0)=1$

$cpot(n)=cpot(n-1)+num(n-1)$

num 该列的非零元素个数

| col  | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| num  | 1    | 3    | 1    | 0    | 1    |
| cpot | 0    | 1    | 4    | 5    | 5    |

cpot表示 转置后的第i列的第一个元素存放的位置

```java
public class Triple<T> {
	int row,col;
	T v;
	public Triple(){}
	public Triple(int row,int col, T v){
		this.row = row;
		this.col = col;
		this.v = v;
	}	
}
public class Mat {
	final int MAXSIZE = 10;
	int mu,nu,tu;
	Triple<Integer> data[] = new Triple[MAXSIZE + 1];//Java不支持泛型数组
	public Mat(int mu,int nu,int tu){
		this.mu = mu;
		this.nu = nu;
		this.tu = tu;
		for(int i=1; i<=MAXSIZE; i++)
			data[i] = new Triple();
	}
	public void display(){
		int i,j,k,m,n,count = 0;
		for(i=1; i<=mu; i++){
			for(j=1; j<=nu; j++){
				for(k=1; k<=tu; k++){
					if(i==data[k].row && j==data[k].col){
						System.out.print(data[k].v + " ");
						count = -1;
						break;
					}
				}
				if(count != -1)
					System.out.print("0 ");
				count = 0;
			}
			System.out.println();
		}
	}
}
package 稀疏矩阵的运算;
import java.util.*;
 
public class Transfer {
 
	public static void main(String[] args) {
		int i,j,k,l;
		Scanner scan = new Scanner(System.in);
		System.out.println("请输入矩阵的行数，列数，非零元的个数：");
		int mu,nu,tu;
		mu = scan.nextInt();
		nu = scan.nextInt();
		tu = scan.nextInt();
		Mat M1 = new Mat(mu,nu,tu);
		Mat M2 = new Mat(nu,mu,tu);
	    System.out.println("请输入矩阵的三元组：");
		for(i=1; i<=tu; i++){
			M1.data[i].row = scan.nextInt();
			M1.data[i].col = scan.nextInt();
			M1.data[i].v = scan.nextInt();
		}
		System.out.println("您输入的矩阵为：");
		M1.display();
		//增加两个向量
		int num[] = new int[nu+1];//M1中第col列中非零元的个数
		int col,row,t;
		for(col=1; col<=nu; col++){
			num[col] = 0;
		}
		for(t=1; t<=tu; t++){
			num[M1.data[t].col]++;
		}
		int cpot[] = new int[nu+1];//M1中第col列的第一个非零元在M2.data中的位置。
		cpot[1] = 1;
		for(col=2; col<=nu; col++){
			cpot[col] = cpot[col - 1] + num[col - 1];
		}
		int p,q;//实现转置
		for(p=1; p<=tu; p++){
		    col = M1.data[p].col;
		    q = cpot[col];
		    M2.data[q].row = M1.data[p].col;
		    M2.data[q].col = M1.data[p].row;
		    M2.data[q].v = M1.data[p].v;
		    cpot[col]++;
		}
		System.out.println("转置后的矩阵为：");
		M2.display();
		
	}
	
}
```

## 队列

先进先出结构  

数组实现循环队列

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210406140648.png" alt="image-20210406140616725" style="zoom:67%;" />

```java
public class Cylicqueue {


    public static void main(String[] args) throws Exception {
        Cylicqueue cylicqueue = new Cylicqueue(2);
        cylicqueue.add(1);
        cylicqueue.add(3);
        cylicqueue.add(4);
        cylicqueue.add(5);
        cylicqueue.foreach();
        System.out.println(cylicqueue.get());
        cylicqueue.foreach();
    }

    private int maxsize;
    //队尾指针
    public int rear = 0;
    //队头指针
    public int front = 0;
    private int[] CQueue;

    public Cylicqueue(int maxsize) {
        this.maxsize = maxsize;
        CQueue = new int[maxsize];
    }


    public boolean isFull() {
        //队尾指针加一取模等于队头则队满了
        return (rear + 1) % maxsize == front ? true : false;
    }

    public boolean isEmpty() {
        //队尾与对头重合 队空了
        return rear == front ? true : false;
    }

    public boolean add(int val) {
        if (isFull()) {
            System.out.println("队列满了");
            return false;
        }
        CQueue[rear] = val;
        //加一取模
        rear = (rear + 1) % maxsize;
        return true;
    }

    public int get() throws Exception {
        if (isEmpty()) {
            System.out.println("队列为空");
            throw new Exception("队列空");
        }
        int tmp = CQueue[front];
        //加一取模
        front = (front + 1) % maxsize;
        return tmp;
    }

    public void foreach() throws Exception {
        int len = (rear - front + maxsize) % maxsize;
        int t[] = new int[len];
        if (isEmpty()) {
            System.out.println("队列为空");
            throw new Exception("队列空");
        }
		//遍历 找到遍历的起点 与终点 起点:front ;终点:front + (rear - front + maxsize) % maxsize
        for (int i = front; i < front + (rear - front + maxsize) % maxsize; i++) {
            System.out.println(CQueue[i % maxsize]);
        }


    }


}
```

## 链表

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210407150932.png" alt="image-20210407150920063" style="zoom:50%;" />

```java
//单链表节点
public class ListNode {
    int val;
    ListNode next;
}
//双向链表节点
class DlistNode{
    int val;
    ListNode pre;
    ListNode next;
}
//leetcode 反转链表
//双指针法
 public static ListNode revers(ListNode head){
     // cur在前 pre在后 
        ListNode pre=null;
        ListNode cur=head;
        ListNode nex=null;
        while (cur!=null){
            //nex 存储cur的next节点 方便移动
            nex=cur.next;
            cur.next=pre;
            pre=cur;
            cur=nex;
        }

       return  cur;
    }
	//递归
    public ListNode reverseList(ListNode head) {
        //递归终止条件是当前为空，或者下一个节点为空
        if(head==null || head.next==null) {
            return head;
        }
        //这里的cur就是最后一个节点
        ListNode cur = reverseList(head.next);
        //如果链表是 1->2->3->4->5，那么此时的cur就是5
        //而head是4，head的下一个是5，下下一个是空
        //所以head.next.next 就是5->4
        head.next.next = head;
        //防止链表循环，需要将head.next设置为空
        head.next = null;
        //每层递归函数都返回cur，也就是最后一个节点
        return cur;
    }
	
//双向链表的删除
	 public DlistNode deletenode(DlistNode dlistNode,int val){
        if (dlistNode.next==null){
            return dlistNode;
        }
       DlistNode tmp=dlistNode;
        while (tmp.next!=null){
            if (tmp==null){
                return dlistNode;
            }else {
                           if (tmp.val==val){
                     //处理尾部节点
                    if (tmp.next==null){
                        tmp.pre.next=null;
                    }else {
                        tmp.pre.next=tmp.next;
                        tmp.next.pre=tmp.pre;
                    }
                }else {
                    tmp=tmp.next;
                }
            }
                 }
        return  dlistNode;

```

