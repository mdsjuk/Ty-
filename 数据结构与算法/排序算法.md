# 排序算法

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/img/image-20210402153337782.png" alt="image" style="zoom: 50%;" />



## 冒泡

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403160843.gif" alt="冒泡" style="zoom:67%;" />

稳定性:相同元素比较不调换位置 ==稳定==

复杂度: 有序时o(n) 无序时o(n^2)

```java
public static  int[] sort(int[] a){
    int len=a.length;
    /** len-1 最后一位不需要比较  第一次需要排j<len-1 **/
    for (int i=0;i<len-1;i++){
        for (int j=0;j<len-1-i;j++){
            if (a[j]>a[j+1]){
                int emp=a[j+1];
                a[j+1]=a[j];
                a[j]=emp;
            }
        }
    }
    return a;
}		
	//优化 一 不需要tmp变量
	//优化 二 每次排序判断是否进行了调换 无调换直接输出
  public static  int[] sort(int[] a){
        int len=a.length;
        /** len-1 最后一位不需要比较 **/
        for (int i=0;i<len-1;i++){
            /**表示是否进行过排序**/
            boolean flag=false;
            for (int j=0;j<len-1-i;j++){
                if (a[j]>a[j+1]){
                    flag=true;
                    /**不借助额外空间进行调换**/
                    a[j+1]=a[j+1]+a[j];
                    a[j]=a[j+1]-a[j];
                    a[j+1]=a[j+1]-a[j];
                }
            }
            if (flag=false) {
                break;
            }
        }
        return a;
    }

```



## 插入

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403161304.gif" alt="插入" style="zoom:67%;" />

稳定性:==稳定== 相同的数插入时不会乱序

复杂度:有序时o(n) ==每次都不需要遍历有序部分 直接插到尾部==

​			无序时o(n^2)

```java
public static void sort(int[] a) {
    int len = a.length;
    for (int i = 1; i < len; i++) {
        int tmp = a[i];
        int pre=i-1;
        /**  将当前节点值 tmp和前pre个值比较 比他大的后移一位**/
        while (pre>=0&&a[pre]>tmp){
            a[pre+1]=a[pre];
            pre--;
        }
        a[pre+1]=tmp;
        }
    }
```

## 希尔 

分组增量插入排序 最后一次插入排序 解决 逆序列问题

​		![希尔](https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403163206.gif)\

稳定性:==不稳定==

复杂度:有序o(n) 无序o(n^2)

```java
public static void sort1(int[] a) {
            for (int gap = a.length / 2; gap > 0; gap /= 2) {
                //从第gap个元素，逐个对其所在组进行直接插入排序操作
                for (int i = gap; i < a.length; i++) {
                     int j = i;
                     /**交叉执行 **/
                    while (j - gap >= 0 && a[j] < a[j - gap]) {
                        //插入排序采用交换法
                        swap(a, j, j - gap);
                        j -= gap;
                    }
                }
            }
        }
```



## 选择

 <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403161118.gif" alt="选择" style="zoom:67%;" />		

稳定性:==不稳定== 反例 5  2  5 1 第一次插入时 1 2  5 5 此时顺序被打乱 

复杂度 有序时o(n^2) 无序时 o(n^2) 

```java
public static int[] sort(int[] a){
        int len=a.length;
        //最小值下标
        int index_min=0;
        //最小值
        int min=a[index_min];
        /**  len-1 最后一位不需要比较**/
        for (int i=0;i<len-1;i++){
            /**每次设置初值**/
            index_min=i;
            for (int j=i;j<len;j++){
                if (a[index_min]>a[j]){
                    index_min=j;
                }
            }
            /** 最小值与i的位置交换**/
            min=a[index_min];
            a[index_min]=a[i];
            a[i]=min;
        }
        return a;
    }
```

## 快速

![快排](https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403195847.gif)

稳定性: 不稳定 

复杂度:

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403204932.png" alt="image-20210403204932352" style="zoom: 80%;" align="center" /> 

  <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403203915.jpg" alt="快排复杂度" style="  zoom: 50%;" align="center" />   	       

  <img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403204227.jpg" alt="快排最坏" style="zoom:50%;" />

```java
private static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        // 找寻基准数据的正确索引
        int index = partion(arr, low, high);
        quickSort(arr, low, index - 1);
        quickSort(arr, index + 1, high);
    }
}
public static int partion(int[] a,int low , int high) {
    //无优化 直接取低位为基准值key
    //优化1 low high median 三数排序后取中（median-of-three）
    //优化2 随机选取基数
    //优化3 如果存在很多重复元素 将与基准key相同的数聚集在一起 
    int tmp = a[low];
    while (low < high) {
        while (low < high && a[high] >= tmp) {
            high--;
        }
        a[low] = a[high];
        while (low < high && a[low] <= tmp) {
            low++;
        }
        a[high]=a[low];
    }
    a[low] = tmp;
    return low; // 返回tmp的正确位置

}
```

## 堆

![堆](https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403232903.gif)



```java
public static void sort(int []arr){
        //1.构建大顶堆 arr.length/2-1 从下向上的第一个非叶子节点位置
        for(int i=arr.length/2-1;i>=0;i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j>0;j--){
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr,0,j);//重新对堆进行调整
        }

    }

    /**
     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
     * @param arr
     * @param i
     * @param length
     */
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i
        for(int k=i*2+1;k<length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            //比较两个子节点的值大小
            if(k+1<length && arr[k]<arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }

            if(arr[k] >temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }

    /**
     * 交换元素
     * @param arr
     * @param a
     * @param b
     */
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```

## 归并

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403205424.gif" alt="归并" style="zoom:67%;" />

稳定性:==稳定==

复杂度:有序o(NlogN) 无序o(NlogN)

```java
private static void sort(int[] arr,int left,int right,int []temp){
    if(left<right){
        int mid = (left+right)/2;
        sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序
        sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序
        merge(arr,left,mid,right,temp);//将两个有序子数组合并操作
    }
}

public static void merge(int[] a,int left,int mid,int right,int [] tmp){
    int i=left;
    int j=mid+1;
    int t=0;
    /**较小的数插入tmp数组**/
    while (i<=mid&&j<=right){
        if (a[i]>=a[j]){
            tmp[t++]=a[j];
            j++;
        }else {
            tmp[t++]=a[i];
            i++;
        }}
        /**剩余尾数插入**/
        while (i<=mid){
            tmp[t++]=a[i++];
        }
        while (j<=right){
            tmp[t++]=a[j++];
        }
        t=0;
        /**tmp数组元素拷贝到原数组**/
        while(left <= right){
            a[left++] = tmp[t++];
        }
}
```

## 计数

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403224400.gif" alt="计数" style="zoom:50%;" />

```java
/**
 * 计数排序
 *
 * @param array
 * @return
 */
public static int[] CountingSort(int[] array) {
    if (array.length == 0) return array;
    int bias, min = array[0], max = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i] > max)
            max = array[i];
        if (array[i] < min)
            min = array[i];
    }
    bias = 0 - min;
    int[] bucket = new int[max - min + 1];
    Arrays.fill(bucket, 0);
    for (int i = 0; i < array.length; i++) {
        bucket[array[i] + bias]++;
    }
    int index = 0, i = 0;
    while (index < array.length) {
        if (bucket[i] != 0) {
            array[index] = i - bias;
            bucket[i]--;
            index++;
        } else
            i++;
    }
    return array;
}
```
## 桶排序

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403232301.png" alt="image-20210403232301016" style="zoom:50%;" />

```java

public class BucketSort extends Sort<Integer>{

    @Override
    protected void sort() {
        // TODO Auto-generated method stub
        //最大最小值
        int max = array[0];
        int min = array[0];
        int length = array.length/4;

        for(int i=1; i<array.length; i++) {
            if(array[i] > max) {
                max = array[i];
            } else if(array[i] < min) {
                min = array[i];
            }
        }

        //最大值和最小值的差
        int diff = max - min;

        //桶列表
        ArrayList<ArrayList<Integer>> bucketList = new ArrayList<>();
        for(int i = 0; i < length; i++){
            bucketList.add(new ArrayList<>());
        }

        //每个桶的存数区间
        float section = (float) diff / (float) (length - 1) ;

        //数据入桶
        for(int i = 0; i < array.length; i++){
            //当前数除以区间得出存放桶的位置 减1后得出桶的下标
            int num = (int) (array[i] / section) - 1;
            if(num < 0){
                num = 0;
            }
            bucketList.get(num).add(array[i]);
        }

        //桶内排序
        for(int i = 0; i < bucketList.size(); i++){
            //jdk的排序速度当然信得过
            Collections.sort(bucketList.get(i));
        }

        //写入原数组
        int index = 0;
        for(ArrayList<Integer> arrayList : bucketList){
            for(int value : arrayList){
                array[index] = value;
                index++;
            }
        }
    }

}
```

## 基数排序

<img src="https://cdn.jsdelivr.net/gh/mdsjuk/Picture/imgs/20210403232432.gif" alt="基数" style="zoom: 50%;" />






